# ckeditor

# installation: pip install flask-ckeditor

# initialization
-> this extension needs to be initialized in the usual way before it can be used.
-> code:
        from flask_ckeditor import CKEditor

        app = Flask(__name__)
        ckeditor = CKEditor(app)

# Include CKEditor resource
-> In the template in which you want to put a CKEditor textarea, call ckeditor.load() in <head> or before </body>
-> i.e
        <body>
            ...
            {{ ckeditor.load() }}
        </body>

-> By default, it will load the CKEditor resources from CND(cdn.ckeditor.com)
-> you can set CKEDITOR_SERVE_LOCAL to True to use built-in resources
-> use custom_url to load your custom CKEditor build
    {{ ckeditor.load(custom_url=url_for('static', filename='ckeditor/ckeditor.js')) }}

# create a CKEditor Textarea
-> just call ckeditor.create() in the template
-> eg.
       <form method="post">
            {{ ckeditor.create() }}
            <input type="submit">
       </form>
-> can use "value" parameter to pass preset value i.e. ckeditor.create(value="...")

# get the data and clean it
-> get the data from request.form by passing ckeditor as key
-> i.e.
       from flask import request, render_template
       from flask_ckeditor.utils import cleanify

       @app.route('/write')
       def new_post():
            if request.method == "POST":
                data = cleanify(request.form.get('ckeditor'))

            return render_template('index.html')

# working with Flask_WTF/WTForms
-> when using FLasK_WTF/WTForms, you can import the CKEditorField provided by Flask-CKEditor and use it like StringField
-> i.e.
        from flask_wtf import FlaskForm
        from flask_ckeditor import CKEditor
        from wtforms import StringField, SubmitField

        class PostForm(FlaskForm):
            title = StringField('Title')
            body = CKEditor('Body')
            submit = SubmitField('Submit')
-> one more step is to call ckeditor.config() and pass the CKEditorField attribute's name
    <form method="post">
        {{ form.title }}
        {{ form.body }}
        {{ form.submit }}
    </form>
    {{ ckeditor.load() }}
    {{ ckeditor.config(name='body') }}
    </body>

-> In the view function, you can get the data either by request.form.get('body') or form.body.data

# Preset value in CKEditor Textarea
-> when you implement an edit feature for your CMS, you will need to get the article data from the database, then
   preset the value into the CKEditor textarea. First you need to pass the value into template
    i.e.
        @app.route('/edit')
        def edit_post():
            article_body = get_article_body_from_somewhere()
            return render_template('edit.html', article_body=article_body)

    then pass it to the CKEditor with value parameter
        <form method="post">
            {{ ckeditor.create(value=article_body) }}
            <input type="submit">
        </form>

-> If you are using Flask_WTF/WTForms,it's even more simple, just pass the value to the form field's data attribute
    @app.route('/edit')
    def edit_post():
        form = EditForm()
        form.body.data = get_article_from_somewhere()
        return render_template('edit.html', form=form)

* Note:
-> the data from the CKEditor is saved as HTML. It contains all the structure and styling of the blog post.
    In order for this structure to be reflected when you go to the template page you need to add "Jinja safe() filter"
    This makes sure that when Jinja renders the template it doesn't treat the HTML as text
-> To apply jinja filter, you need the pipe symbol "|" and this goes between the Jinja expression and Jinja filter
    e.g. {{ Jinja Expression | Jinja Filter }}